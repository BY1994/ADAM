function varargout=ShapeFamily(varargin);% ShapeFamily.m v1.0%% Please send bug reports, comments, and suggestions to: Charles A. Collin% (ccollin@is.dal.ca)%% The following provides basic directions for using ShapeFamily.m.  For more% complete instructions, see Collin and McMullen (submitted).%% ShapeFamily makes families of similar two-dimensional irregular polygons. It% does this by generating a prototype shape and then modifying it in various% random ways to create the family members. The user passes parameters to the% function (see below), which modify the appearance of the prototype and the% derived family. The algorithm used to generate the shapes is very similar to% that suggested by Attneave and Arnoult (1956).%% Usage: [Xf, Yf, Xp, Yp]=ShapeFamily('Param1', 'Val1', 'Param2', 'Val2', ...);%%% PARAMETERS:%% Any number of parameter/value pairs may be passed, and they may be passed in% any order. If none are passed, a dialog box is activated in which the user% may enter parameter values. The parameters that may be modified are:%% NMembers: The number of members in a generated family. Default: 4%% NSides: The number of sides of each generated shape. Default: 6%% NPts2Shift: This is the number of vertices of the prototype to shift when% making family members. Normally it will be set to the same value as NSides.% Default: 6%% PtsMethod: When NPts2Shift is less than NSides, this is the method for% choosing which points to shift.  Possible values are: 'r' for random, 'c' for% constant and 's' for sequential. The random method simply chooses a new set% of points at random for each family member generated. The constant method% shifts the same set of vertices when creating each family member. The% sequential method incrementally moves around the shape shifting a new set of% points in order for each family member generated. Default: 'r'.%% ShiftLims: This is a two element vector containing the minimum and maximum% distances that a point can be shifted when creating a new family member. If% the two values are set to the same number, the shifts will always be the same% distance.  Default: [0 1]%% LengthLims: This is a two element vector containing the minimum and maximum% lengths of the sides of a shape. Any generated shape that has sides exceeding% these boundaries is rejected and a new shape is generated to take its place.% As the two values approach one another, the function may come to take some% time to run, as many shapes will have to be generated before one which fits% within the criteria is obtained. Default: [0.05 1.00]%% AngleLims: This is a two element vector containing the minimum and maximum% acute angles (in degrees) at the vertices of the generated shapes.  Any shape% that has vertex angles exceeding these boundaries is rejected and a new shape% is generated to take its place. As the two values approach one another, the% function may come to take some time to run, as many shapes will have to be% generated before one which fits within the criteria is obtained. Default: [5% 175]%% FamilyName: The name of the shape family. This is a string, so 'Smith',% 'One', '12', and so on are all allowable values. Default: 'shape'.%% FamilyRes: This measures the 'family resemblance' of the generated polygons.% It is a value between 0 and 1. The higher the value, the more similar the% polygons will be to the prototype and to each other. Default: .90%% TopolMethod: ShapeFamily.m is capable of checking the topological integrity% of the generated shapes.  That is, it can check if the generated shapes% consist of single integral body without easily seperable parts.  This is done% by first applying several pixel-wise erosions to the generated shape and then% checking to see if it still consists of a single contiguous patch of "on"% pixels.  There are three values which may be entered for this parameter: 'n'% for none, 'f' for fast and 'c' for complete.  If 'n' is selected, then no% topological checking is performed. If 'f' is selected then a relatively quick% check of topological unity is done.  If 'c' is chosen, then a more complete% but time-consuming check is done. Default: 'n'%% NErosions: This is the number of pixel-wise erosions done to seperate parts% when doing the topological check. The higher this number, the stricter the% definition of shape integrity is. Default: 3%% CrossCheck: Normally, CrossCheck is set to 'y', in which case the function% ensures that no lines in the generated shapes cross one another.  If it is% set to 'n', then lines are allowed to cross, approximating Attneave and% Arnoult's (1956) method 2. Default: 'y'%% MakePix: Normally, MakePix is set to 'y', in which case the function outputs% the generated shapes as a set of TIFF files in the directory where% ShapeFamily.m is executed.  It may be set to 'n' to disable this feature.% Default: 'y'%% ImageSize: This is the size of the images generated by the function when% MakePix is 'y'.  The images are always square. Default: 256.%% PrototypeX and PrototypeY: If these parameters are passed, the function does% not generate a prototype on its own, but instead uses the coordinates passed% for the prototype of the family.  ShapeFamily will derive the number of% linesegments in the family members from the prototype, over-riding any passed% 'NSides' value.  The passed values must consist of two vectors containing% values from 0 to 1.  No default value.%%% RETURN VALUES:%% ShapeFamily returns up to 4 sets of values.%% Xf and Yf:  These are a pair of matrices containing the coordinates of the% generated shape family in absolute terms.  Thus all values in the matrix will% be 0 to 1.  Each row of the matrix contains the coordinates for a different% shape, and there will be as many columns as there are line segments in the% shape.%% Xp and Yp: These are a pair of vectors containing the coordinates of the% generated prototype. They are 'NSides' long.%%% RUN TIME%% ShapeFamily can take from seconds to hours to run, depending on the% parameters passed to it and of course on the hardware it is being run on.  In% general, the program will run slowly if asked to generate polygons with many% sides, or with narrow constraints as to angles or distances. Topological% integrity checking can take a great deal of time, especially with many-sided% polygons.%%% EXAMPLES%% [Xf, Yf, Xp, Yp]=ShapeFamily;%% This will cause a dialog window to appear, in which the user may enter% parameter values. The shape coordinates will be returned in Xf and Yf, and% the shapes will be output to tiff files with the names shape01.tiff,% shape02.tiff, . . .  The prototype shape coordinates will be returned in Xp% and Yp, and the shape output to shapeproto.tiff.%% [Xf, Yf, Xp, Yp]=ShapeFamily('NMembers', 20, 'NSides', 11); This will% generate a family of 20 shapes with 11 sides each.%% [Xf, Yf, Xp, Yp]=ShapeFamily('ImageSize', 512, 'TopolMethod', 'fast'); Same% as above, but the saved images will be 512 x 512 pixels in size.  TopolCheck% is set to 'fast' to perform a basic topological integrity check.%% [Xf1, Yf1, Xp, Yp]=ShapeFamily('FamilyName', 'One'); [Xf2,% Yf2]=ShapeFamily('FamilyName', 'Two', 'PrototypeX', Xp, 'PrototypeY', Yp);% Executing these two commands in sequence will create two families based off% the same prototype.%%% REFERENCES%% Attneave, F., and Arnoult, M.D. (1956). The quantitative study of shape and% pattern perception, Psychological Bulletin, 53, 452-471.%% Collin, C., and McMullen, P.A. (submitted). Using MATLAB on MacIntosh to% Generate Families of Similar Shapes.  Submitted to Behavior Research Methods,% Instruments, and Computers%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   ASSIGN PARAMETERS   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% First, create table of parameter names, values and promptsParameters = { 																				...    'NMembers',		'4',		'Number of family members to generate (0-50): ';	...    'NSides',		'6',		'Number of sides per shape (3-24+): ';					...    'NPts2Shift',	'6',		'Number of vertices to shift (0 to # of sides) : ';...    'PtsMethod',	'r',		'Shifted point selection method (r, c, or s) ';		...    'ShiftLims',	'0 1',	'Min&Max vertex shifts (0-1): ';							...    'LengthLims',	'.05 1',	'Min&Max side lengths (0-1): ';							...    'AngleLims',	'5 175',	'Min&Max vertex angles (0-180): ';						...    'FamilyName', 	'shape', 'Family name: ';												...    'FamilyRes',	'.9',		'Family resemblance coefficient (0-1): ';				...    'TopolMethod',	'n',		'Topology checking method (f, c, or n)?';				...    'NErosions',	'3',		'Number of erosions to seperate parts (0-5+): ';	...    'CrossCheck',	'y',		'Check for line crossings? ("y" or "n"): ';			...    'MakePix',		'y',		'Make pictures? ("y" or "n"): ';							...    'ImageSize',	'256',	'Size of output images in pixels: ';					...    'PrototypeX',	'',		'X coordinates of prototype shape: '; 					...    'PrototypeY',	'',		'Y coordinates of prototype shape: ';					...    };% If no parameters were input at the command lines, pop up windows% to get their values.if nargin == 0    ParamInputs = inputdlg(Parameters(:,3), 'Enter Shape Parameters', 1, 	...        Parameters(:,2));        [Parameters{:,2}] = deal(ParamInputs{:});end% Now assign each parameter in the table to its valuefor par = 1:size(Parameters,1)    if isempty(str2num(Parameters{par,2})) % for string entries        eval([Parameters{par,1} '=''' Parameters{par,2} ''';']);    else												% for number entries        eval([Parameters{par,1} '=[' Parameters{par,2} '];']);    endend% If there were inputs at the command line, use thosefor x=1:2:nargin    if ~exist(varargin{x})			% check for non-parameter entries        error(['''' varargin{x} ''' is not a recognized parameter.']);    elseif ischar(varargin{x+1}) 	% if a string entry        eval([varargin{x} '=''' varargin{x+1} ''';']);    elseif ~ischar(varargin{x+1})	% if a numerical entry        eval([varargin{x} '=[' num2str(varargin{x+1}) '];']);    endendrand('state', fix(1e6*sum(clock))); % Seed the random number generator%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  GENERATE PROTOTYPE SHAPE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% IF NO PROTOTYPE HAS BEEN HANDED TO THE FUNCTION, IT GENERATES ONEif isempty(PrototypeX)        ProtoTypeOkay=0;    while ~ProtoTypeOkay        ProtoX = rand(1,NSides);  % make random points        ProtoY = rand(1,NSides);                ConvexDex = convhull(ProtoX,ProtoY);  % Get the convex hull indexes.                % Get the coordinates of points on the convex hull        ProtoXConv = ProtoX(ConvexDex(1:end-1));        ProtoYConv = ProtoY(ConvexDex(1:end-1));                % Get the indexes of points inside the hull        % InDex = inpolygon(ProtoX, ProtoY, ProtoXConv, ProtoYConv);        InDex = ~ismember(ProtoX, ProtoXConv);                        % Get the coordinates of points inside the hull        ProtoXIn = ProtoX(InDex==1);        ProtoYIn = ProtoY(InDex==1);                % Shuffle the order of the inside points        % They will be attached to the outer hull in the shuffled order        [null, sdex] = sort(rand(size(ProtoXIn)));        ProtoXIn = ProtoXIn(sdex);        ProtoYIn = ProtoYIn(sdex);                % TestX and TestY are the coordinates to be tried out.  To begin        % they are assigned to be equal to the points on the Convex Hull.        TestX = ProtoXConv; TestY = ProtoYConv;                        % For each point inside the hull, try inserting its coordinates into the        % list of coordinates for points that are on the hull.  The place of        % insertion into the list is random.  Generate the polygon thus defined        % and check if it has any crossing lines.  If it does, try the next list        % insertion placement, otherwise move on to insert the next point that is        % inside the polygon.        ProtoTypeOkay = 1;        ProtoTypeFailed = 0;        for InsertDex = 1:length(ProtoXIn)                        % Create random order in which to try insertion points.            InsertOrder = shuffle(1:length(TestX));                        for p = 1:length(InsertOrder)                                % Insert the new coordinate in the list of coordinates already                % on the polygon                TestX(InsertOrder(p)+1:end+1) = TestX(InsertOrder(p):end);                TestY(InsertOrder(p)+1:end+1) = TestY(InsertOrder(p):end);                                TestX(InsertOrder(p)) = ProtoXIn(InsertDex);                TestY(InsertOrder(p)) = ProtoYIn(InsertDex);                                % Check to see if the new shape has line crossings in it                CrossOkay = CheckCross([TestX, TestX(1)], [TestY, TestY(1)],	...                    CrossCheck);                                                % If there is a crossing, undo the insertion                if ~CrossOkay                    TestX(InsertOrder(p):end-1) = TestX(InsertOrder(p)+1:end);                    TestY(InsertOrder(p):end-1) = TestY(InsertOrder(p)+1:end);                    TestX = TestX(1:end-1);                    TestY = TestY(1:end-1);                else                    % if the point is okay with the currently attempted insertion                    % break out and move on to place the next inside point.                    break;                end            end                    end                % If the prototype has been successfully created by the above,        % check it for other criteria, rejecting and starting anew if        % any are not met.        if ProtoTypeOkay                        LengthOkay = 1; AngleOkay = 1; TopolOkay = 1;                        LengthOkay = CheckLength(TestX,TestY, LengthLims(1), LengthLims(2));            if LengthOkay                AngleOkay  = CheckAngle(TestX, TestY, AngleLims(1), AngleLims(2));                if AngleOkay                    TopolOkay  = CheckTopol(TestX, TestY, NErosions, TopolMethod);                end            end                        if any([~LengthOkay, ~AngleOkay, ~TopolOkay]);                ProtoTypeOkay = 0;            end        end                    end        % If the set of coordinates passes all criteria, they become the    % prototype coordinates.    Xp = TestX;    Yp = TestY;        % IF A PROTOTYPE HAS BEEN HANDED TO THE FUNCTION, IT CHECKS IF IT PASSES    % THE SHAPE CRITERIA AND USES ITelse            % Assign input coordinates to prototype coordinates    Xp = PrototypeX;	Yp = PrototypeY;        NSides = length(Xp);  % Derive # of sides from length of passed prototype        % Check if the prototype meets criteria    LengthOkay = 1; AngleOkay = 1; TopolOkay = 1; CrossOkay = 1;        LengthOkay = CheckLength(Xp,Yp, LengthLims(1), LengthLims(2));    if LengthOkay        AngleOkay  = CheckAngle(Xp,Yp, AngleLims(1), AngleLims(2));        if AngleOkay            TopolOkay  = CheckTopol(Xp,Yp, NErosions, TopolMethod);            if TopolOkay                CrossOkay  = CheckCross([Xp, Xp(1)], [Yp, Yp(1)], CrossCheck);            end        end    end        % Display error if prototype is not acceptable    if     length(Xp) ~= length(Yp)        error('Length of ProtoTypeX and ProtoTypeY must be the same');    elseif (Xp>1 || Xp<0) || (Yp>1 || Yp<0)        error('All entered prototype coordinates must be in range 0 to 1');    elseif ~LengthOkay        error('Line(s) in prototype are not within length limits');    elseif ~AngleOkay        error('Angle(s) in prototype are not within angle limits');    elseif ~TopolOkay        error('Prototype has failed topological check');    elseif ~CrossOkay        error('Lines in prototype cross one another');    end    end% Print the prototype image out to a TIFF fileif MakePix == 'y'    img = flipud(~roipoly(repmat(0, ImageSize, ImageSize), ...        Xp * ImageSize, Yp * ImageSize));    imwrite(img, [FamilyName, 'Proto.tiff'], 'tiff', 'compression', 'ccitt');end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   GENERATE FAMILY MEMBERS   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Xf = ''; Yf = ''; % Assign empty matrices for shape coordinatesLengthOkay = 0; AngleOkay = 0; TopolOkay = 0;% For the 'constant' or 'sequential' shifted point selection methods,% generate a random set of points to be shifted.if (PtsMethod == 'c') || (PtsMethod == 's')    PointIndexes = 1:NSides;    [null, sdex] = sort(rand(size(PointIndexes)));    PointIndexes = PointIndexes(sdex);        StaticPtIndexes = PointIndexes(1:(NSides-NPts2Shift));endMembersMade = 0;while MembersMade < NMembers        while 1        % For each family member, generate a new set of coordinate        % offsets (shifts).        xyShiftLengths = rand(1,NSides) * (1-FamilyRes);                % Check to make sure the shifts are within the desired limits        xyShiftLengths(find(xyShiftLengths > ShiftLims(2) )) = ShiftLims(2);        xyShiftLengths(find(xyShiftLengths < ShiftLims(1) )) = ShiftLims(1);                % If a random set of points are being shifted on each family        % member, generate a new set of points each time.        if PtsMethod == 'r'            PointIndexes = 1:NSides;            [null, sdex] = sort(rand(size(PointIndexes)));            PointIndexes = PointIndexes(sdex);            StaticPtIndexes = PointIndexes(1:(NSides-NPts2Shift));        end                        xyShiftLengths(StaticPtIndexes) = 0;                % Create shift angles (0 to 360) and then derive x & y shifts        xyShiftAngles = rand(1,NSides) * pi * 2;                xshifts = cos(xyShiftAngles) .* xyShiftLengths;        yshifts = sin(xyShiftAngles) .* xyShiftLengths;                % Apply the shifts to the prototype's coordinates        % to generate a new family member.        XMem = Xp + xshifts;        YMem = Yp + yshifts;                % Check that coordinates are all still in 0 to 1 range.        if all([XMem>0, XMem<1, YMem>0, YMem<1]);            break;        end    end        % Check that the family member fits the various shape criteria.    LengthOkay = 1; AngleOkay = 1; TopolOkay = 1; CrossOkay = 1;        LengthOkay = CheckLength(XMem, YMem, LengthLims(1), LengthLims(2));    if LengthOkay        AngleOkay  = CheckAngle(XMem, YMem, AngleLims(1), AngleLims(2));        if AngleOkay            TopolOkay  = CheckTopol(XMem, YMem, NErosions, TopolMethod);            if TopolOkay                CrossOkay  = CheckCross([XMem,XMem(1)],[YMem,YMem(1)], CrossCheck);            end        end    end        if all([LengthOkay, AngleOkay, TopolOkay, CrossOkay])        MembersMade = MembersMade + 1;                Xf = [Xf; XMem];  % Save coordinates of generated        Yf = [Yf; YMem];  % family members.                % If points to be shifted are being sequentially moved around        % for each family member        if PtsMethod == 's'            StaticPtIndexes = StaticPtIndexes+1;            StaticPtIndexes(find(StaticPtIndexes > NSides)) = 1;        end                % Print the image out to a TIFF file        if MakePix == 'y'            img = flipud(~roipoly(repmat(0, ImageSize, ImageSize), ...                XMem*ImageSize, YMem*ImageSize));                        imwrite(img, [FamilyName, sprintf('%.2d',MembersMade) '.tiff'],	...                'tiff', 'compression', 'ccitt');        end            endend% Finish up and provide output argumentsclose('all');if nargout >= 2    varargout{1} = Xf;    varargout{2} = Yf;endif nargout == 4    varargout{3} = Xp;    varargout{4} = Yp;end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  MINOR FUNCTIONS  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION CheckAnglefunction okay = CheckAngle(X, Y, MinAngle, MaxAngle);% CheckAngle takes a set of points contained in the vectors X and Y,% and checks them to make sure the angles between all sets of 3 adjacent% points are within MinAngle and MaxAngle.okay = 1;if (MinAngle == 0) & (MaxAngle == 180)    return;endX = [X, X(1:2)];  % Add the first two coords on the end in order toY = [Y, Y(1:2)];	% check the wrap-around of the polygon.for a = 1:size(X,2) -2    warning off; % to get rid of divide by zero warnings    if getangle(X(a),Y(a), X(a+1),Y(a+1), X(a+2),Y(a+2)) <MinAngle | 	...            getangle(X(a),Y(a), X(a+1),Y(a+1), X(a+2),Y(a+2)) >MaxAngle        okay = 0;        return;    end    warning on;end% FUNCTION CheckLengthfunction okay = CheckLength(X,Y, MinLength, MaxLength);% CheckLength takes a set of coordinates contained in the vectors X and% Y, and checks them to make sure the distance between any two adjacent% points is greater than MinLength and less than MaxLength.okay = 1;if (MinLength == 0) & (MaxLength == 1)    return;endX = [X, X(1)];   	% Add the first point onto the end in order toY = [Y, Y(1)];		% check the wrap-around of the polygon.for a = 1:size(X,2) -1    if (getdist(X(a), Y(a), X(a+1), Y(a+1)) < MinLength) |	...            (getdist(X(a), Y(a), X(a+1), Y(a+1)) > MaxLength)        okay = 0;        return;    endend% FUNCTION CheckCrossfunction okay = CheckCross(X,Y, CrossCheck);% Checks to see if any of the lines in the polygon defined by X,Y% cross one another.  The poly must be closed, so the last coordinate% in the set much match the first.okay = 1;if CrossCheck == 'n'    return;endtol = 0.000001;  % Tolerance value for vertex position% Check each pair of lines in the polygon to see if they crossfor g = 1:length(X)-1    for h = 1:length(Y)-1                % First, calculate the equations of the two lines        % (warnings are suppressed due to possibility of vertical lines)        warning off;        b1 = (Y(g+1)-Y(g))/(X(g+1)-X(g));        b2 = (Y(h+1)-Y(h))/(X(h+1)-X(h));        warning on;        % If either line is vertical set slope to "very high" instead of Inf        if b1 == Inf            b1 = 1000000;        end        if b2 == Inf            b2 = 1000000;        end        % If lines are parallel, offset one slightly to avoid intersection        % at infinity        if b1 == b2            b1 = b1 + 0.000001;        end                % Calculate intercepts of both lines        a1 = Y(g) - b1*X(g);        a2 = Y(h) - b2*X(h);                % Calculate point where lines will intersect        xi = -(a1-a2) / (b1-b2);        yi = a1 + b1 * xi;                % If the intersection point is within the limits of both lines        % and the point is not a vertex of the polygon, then there is a        % crossing of lines.        if all([((X(g)-xi)*(xi-X(g+1)) >= 0), ((X(h)-xi)*(xi-X(h+1)) >= 0), 	...                ((Y(g)-yi) * (yi-Y(g+1)) >= 0), ((Y(h)-yi) * (yi-Y(h+1)) >= 0), 	...                (abs(xi-X(g)) > tol & abs(yi-Y(g)) > tol), 								...                (abs(xi-X(g+1)) > tol & abs(yi-Y(g+1)) > tol), 							...                (abs(xi-X(h)) > tol & abs(yi-Y(h)) > tol), 								...                (abs(xi-X(h+1)) > tol & abs(yi-Y(h+1)) > tol)]);            okay = 0;            break;        end    end        if okay == 0        break;    end    end% FUNCTION CheckTopolfunction okay = CheckTopol(X,Y,NErode, TopolMethod);% CheckTopol takes a set of coordinates passed in the vectors X and Y,% generates the polygon they represent and checks to make sure it is a% single integrated shape with no holes in it.okay = 1;% If TopolMethod is 'none' return immediatelyif TopolMethod == 'n'    return;end% Generate image of the polygonimg = roipoly(repmat(0,256,256), X*256,Y*256);% First do the fast check, checking if Euler number is initially 1.% If not, shape is not okay.if (bweuler(img) ~= 1)    okay = 0; return;end% If shape passed first test, erode it a few times, checking after each% erosion.  If at any point, Euler ~= 1, shape is not okay.for E = 1:NErode    if bweuler(bwmorph(img, 'erode', E)) ~= 1        okay = 0; return;    endend% Then the full check if requested. Flood fill from image origin and check% the number of holes in the image.  If not 0, shape is not okay.if TopolMethod == 'f' % full    if ((bweuler(bwfill(img, 1,1,4))-1) * -1) ~= 0        okay = 0; return;    endend% FUNCTION getdistfunction dist = getdist(x1,y1,x2,y2);dist = ((x1-x2)^2 + (y1-y2)^2)^.5;% FUNCTION getanglefunction angle = getangle(x1,y1,x2,y2,x3,y3);% Given three points in cartesian space, x1 y1, x2 y2, and x3 y3,% returns the acute angle at x2 y2 in degrees.p1 = [x1 y1];  p2 = [x2 y2];  p3 = [x3 y3];v1 = p1 - p2;v2 = p3 - p2;angle = acos(v1*v2' / (norm(v1)*norm(v2))) * 180/pi;% FUNCTION shufflefunction [out,dex] = shuffle(in)% Randomly shuffles positions of elements of in[dummy,dex] = sort(rand(size(in)));out = in(dex);